# GenerateDTO

GenerateDTO is an automatic DTO generator utilizing Swift's Macro functionality. By simply adding the `@GenerateDTO` annotation to your classes, corresponding Data Transfer Objects (DTOs) are automatically generated.

## Features

- Automatically generates DTO structures from model classes
- Generated DTOs conform to Sendable, allowing safe data sharing between actors
- Provides bidirectional conversion methods between models and DTOs
- Supports nested DTOs (including collections and optional types)

## Installation

### Using Swift Package Manager

Add the dependency to your `Package.swift` file:

```swift
dependencies: [
    .package(url: "https://github.com/RyujiUeda/GenerateDTO.git", from: "0.1.0")
]
```

Add it to your target dependencies:

```swift
targets: [
    .target(
        name: "YourTargetName",
        dependencies: ["GenerateDTO"]
    )
]
```

## Usage

### Basic Usage

1. Add `import GenerateDTO` to your file
2. Add the `@GenerateDTO` annotation to any class you want to convert to a DTO

```swift
import GenerateDTO

@GenerateDTO
public final class Person {
    public var id: UUID
    public var name: String
    public var age: Int
    
    public init(id: UUID = UUID(), name: String, age: Int) {
        self.id = id
        self.name = name
        self.age = age
    }
}
```

### Handling Nested DTOs

When you have properties that are also DTO-convertible classes, specify them using the `nestedDTOs` parameter:

```swift
@GenerateDTO(nestedDTOs: ["Address", "Order"])
public final class Customer {
    public var id: UUID
    public var name: String
    public var address: Address?
    public var orders: [Order]
    
    // initializer...
}
```

In this example, `Address` and `Order` classes should also be annotated with `@GenerateDTO`.

## Conversion Examples

```swift
// Create a model instance
let person = Person(name: "John Doe", age: 30)

// Convert to DTO
let personDTO = person.toDTO()
print(type(of: personDTO)) // PersonDTO

// Convert back to model
let reconstructedPerson = personDTO.toModel()
print(type(of: reconstructedPerson)) // Person
```

### Concurrency Support and Data Sharing Between Actors

All DTOs generated by GenerateDTO conform to the `Sendable` protocol, allowing them to safely cross actor boundaries in Swift's Concurrency model. This enables safe data sharing between different actors, even for model objects that don't conform to Sendable.

```swift
// Model class (not Sendable)
class UserProfile {
    var name: String
    var settings: [String: Any] // Cannot conform to Sendable due to Any type
    
    init(name: String, settings: [String: Any]) {
        self.name = name
        self.settings = settings
    }
}

// Generate DTO (conforms to Sendable)
@GenerateDTO
class UserProfileDTO {
    var name: String
    var settingsJSON: String // Converted to JSON string for Sendable compliance
    
    init(name: String, settingsJSON: String) {
        self.name = name
        self.settingsJSON = settingsJSON
    }
}

// Usage example
actor UserManager {
    func updateProfile(dto: UserProfileDTO) async {
        // Can safely receive and process the DTO
        let profile = dto.toModel()
        // ...processing...
    }
}

// Elsewhere
let profile = UserProfile(...)
let dto = profile.toDTO() // Convert to Sendable-compliant DTO

// Safely pass DTO to an actor
await userManager.updateProfile(dto: dto)
```

This enables safe value passing across actor boundaries, even for complex data structures.

### Using Parameterized Initializers

You can create DTOs directly without having model class instances:

```swift
// Create DTO directly
let addressDTO = AddressDTO(
    street: "1 Infinite Loop", 
    city: "Cupertino"
)

let personDTO = PersonDTO(
    id: UUID(),
    name: "Jane Smith", 
    age: 28,
    address: addressDTO
)

// Convert to model if needed
let person = personDTO.toModel()
```

This is particularly useful for:
- Creating test data
- Directly deserializing JSON to DTOs
- Building DTOs from user input
- Working with APIs that return DTO-compatible data

## Supported Type Conversions

GenerateDTO supports the following patterns:

- Regular types: `NestedType` → `NestedTypeDTO`
- Optional types: `NestedType?` → `NestedTypeDTO?`
- Array types: `[NestedType]` → `[NestedTypeDTO]`
- Optional array types: `[NestedType]?` → `[NestedTypeDTO]?`

## Requirements

- Target classes must have `public` or `internal` access level
- Properties used for DTO conversion must have appropriate access levels
- Classes specified in `nestedDTOs` must also be annotated with `@GenerateDTO`

## License

This project is available under the MIT License. See the [LICENSE](LICENSE) file for details.

## Contributing

Bug reports and feature requests are welcome through GitHub Issues. Pull requests are also appreciated.

## Acknowledgements

This project leverages Swift Macros functionality and acknowledges the excellent work of the Swift language team.